{"version":3,"file":"preact.mjs","sources":["../src/constants.js","../src/util.js","../src/create-element.js","../src/diff/refs.js","../src/diff/props.js","../src/tree.js","../src/diff/mount.js","../src/create-context.js","../src/diff/unmount.js","../src/diff/children.js","../src/diff/patch.js","../src/component.js","../src/options.js","../src/diff/catch-error.js","../src/diff/commit.js","../src/create-root.js","../src/render.js","../src/clone-element.js","../src/create-portal.js"],"sourcesContent":["// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n","export const isArray = Array.isArray;\n","import { UNDEFINED } from './constants';\nimport options from './options';\nimport { isArray } from './util';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (children !== undefined) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\tconstructor: undefined,\n\t\t_vnodeId: ++vnodeId\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\n/**\n * @param {import('./internal').ComponentChildren} childVNode\n * @returns {import('./internal').VNode | string | null}\n */\nexport function normalizeToVNode(childVNode) {\n\tlet type = typeof childVNode;\n\tif (\n\t\tchildVNode == null ||\n\t\ttype == 'boolean' ||\n\t\ttypeof childVNode == 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (type == 'object' || type == 'function') {\n\t\tif (isArray(childVNode)) {\n\t\t\treturn createElement(Fragment, null, childVNode);\n\t\t}\n\n\t\treturn childVNode;\n\t}\n\n\treturn String(childVNode);\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === UNDEFINED;\n","import options from '../options';\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').Internal} internal\n */\nexport function applyRef(ref, value, internal) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse if (ref) ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, internal);\n\t}\n}\n","import options from '../options';\n\nfunction setStyle(dom, key, value) {\n\tif (key[0] === '-') {\n\t\tdom.style.setProperty(key, value == null ? '' : value);\n\t} else {\n\t\tdom.style[key] = value == null ? '' : value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {number} isSvg 0 if not an SVG element, else it is an SVG element\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tsetStyle(dom, 'cssText', value);\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tsetStyle(dom, 'cssText', (oldValue = ''));\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!value || !(name in value)) {\n\t\t\t\t\t\tsetStyle(dom, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (name in value) {\n\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\tsetStyle(dom, name, value[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'width' &&\n\t\t\tname !== 'height' &&\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname !== 'rowSpan' &&\n\t\t\tname !== 'colSpan' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\treturn this._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals have an ID of 0 that is never used:\n\tlet vnodeId = 0;\n\n\tif (typeof vnode == 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t}\n\t// Prevent JSON injection by rendering injected objects as empty Text nodes\n\telse if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props;\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type == 'function'\n\t\t\t\t? type.prototype && type.prototype.render\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tdata:\n\t\t\tflags & TYPE_COMPONENT\n\t\t\t\t? { _commitCallbacks: [], _context: null, _stateCallbacks: [] }\n\t\t\t\t: null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_component: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} offset\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, offset) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (; offset < internal._children.length; offset++) {\n\t\tlet child = internal._children[offset];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child.data;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child, 0);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\t// @TODO: compare performance of recursion here (it's 11b smaller, but may be slower for deep trees)\n\treturn internal.data._context || getParentContext(internal._parent);\n\n\t// while ((internal = internal._parent)) {\n\t// \tlet context = internal._context;\n\t// \tif (context != null) return context;\n\t// }\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parent = internal;\n\n\t// if this is a Root internal, return its parent DOM:\n\tif (parent.flags & TYPE_ROOT) {\n\t\treturn parent.props._parentDom;\n\t}\n\n\t// walk up the tree to find the nearest DOM or Root Internal:\n\twhile ((parent = parent._parent)) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\treturn parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\treturn parent.data;\n\t\t}\n\t}\n}\n","import { applyRef } from './refs';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_ELEMENT,\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG,\n\tDIRTY_BIT\n} from '../constants';\nimport { normalizeToVNode, Fragment } from '../create-element';\nimport { setProperty } from './props';\nimport { createInternal, getParentContext } from '../tree';\nimport options from '../options';\nimport { ENABLE_CLASSES } from '../component';\nimport { commitQueue } from './commit';\nimport { isArray } from '../util';\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').PreactElement} parentDom The element into which this subtree is rendered\n * @param {import('../internal').PreactNode} startDom\n * @returns {import('../internal').PreactNode | null} pointer to the next DOM node to be hydrated (or null)\n */\nexport function mount(internal, newVNode, parentDom, startDom, refs) {\n\tif (options._diff) options._diff(internal, newVNode);\n\n\t/** @type {import('../internal').PreactNode} */\n\tlet nextDomSibling, prevStartDom;\n\n\ttry {\n\t\tif (internal.flags & TYPE_COMPONENT) {\n\t\t\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t\t\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t\t\t// top.\n\t\t\tif (\n\t\t\t\tinternal.flags & TYPE_ROOT &&\n\t\t\t\tnewVNode.props._parentDom !== parentDom\n\t\t\t) {\n\t\t\t\tparentDom = newVNode.props._parentDom;\n\t\t\t\tprevStartDom = startDom;\n\t\t\t\tstartDom = null;\n\t\t\t}\n\n\t\t\tconst renderResult = mountComponent(internal, startDom);\n\t\t\tif (renderResult === startDom) {\n\t\t\t\tnextDomSibling = startDom;\n\t\t\t} else {\n\t\t\t\tnextDomSibling = mountChildren(\n\t\t\t\t\tinternal,\n\t\t\t\t\trenderResult,\n\t\t\t\t\tparentDom,\n\t\t\t\t\tstartDom,\n\t\t\t\t\trefs\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tinternal.data._commitCallbacks &&\n\t\t\t\tinternal.data._commitCallbacks.length\n\t\t\t) {\n\t\t\t\tcommitQueue.push(internal);\n\t\t\t}\n\t\t} else {\n\t\t\t// @TODO: we could just assign this as internal.dom here\n\t\t\tlet hydrateDom =\n\t\t\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)\n\t\t\t\t\t? startDom\n\t\t\t\t\t: null;\n\n\t\t\tnextDomSibling = mountElement(internal, hydrateDom, refs);\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t} catch (e) {\n\t\tinternal._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\n\t\tif (internal.flags & MODE_HYDRATE) {\n\t\t\t// @ts-ignore Trust me TS, nextSibling is a PreactElement\n\t\t\tnextDomSibling = startDom && startDom.nextSibling;\n\t\t\tinternal.data = startDom; // Save our current DOM position to resume later\n\t\t}\n\t\toptions._catchError(e, internal);\n\t}\n\n\treturn prevStartDom || nextDomSibling;\n}\n\n/**\n * Construct (or select, if hydrating) a new DOM element for the given Internal.\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} dom A DOM node to attempt to re-use during hydration\n * @returns {import('../internal').PreactNode}\n */\nfunction mountElement(internal, dom, refs) {\n\tlet newProps = internal.props;\n\tlet nodeType = internal.type;\n\tlet flags = internal.flags;\n\n\t// Are we rendering within an inline SVG?\n\tlet isSvg = flags & MODE_SVG;\n\n\t// Are we *not* hydrating? (a top-level render() or mutative hydration):\n\tlet isFullRender = ~flags & MODE_HYDRATE;\n\n\t/** @type {any} */\n\tlet i, value;\n\n\t// if hydrating (hydrate() or render() with replaceNode), find the matching child:\n\tif (flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)) {\n\t\twhile (\n\t\t\tdom &&\n\t\t\t(nodeType ? dom.localName !== nodeType : dom.nodeType !== 3)\n\t\t) {\n\t\t\tdom = dom.nextSibling;\n\t\t}\n\t}\n\n\tlet isNew = dom == null;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (isNew) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\tdom = document.createTextNode(newProps);\n\t\t} else if (dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\n\t\tinternal.data = dom;\n\t} else {\n\t\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\t\t// if (nodeType === 'svg') internal.flags |= MODE_SVG;\n\n\t\tif (isNew) {\n\t\t\tif (isSvg) {\n\t\t\t\tdom = document.createElementNS(\n\t\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnewProps.is && newProps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\t\tinternal.flags = flags &= RESET_MODE;\n\t\t\tisFullRender = 1;\n\t\t}\n\n\t\t// @TODO: Consider removing and instructing users to instead set the desired\n\t\t// prop for removal to undefined/null. During hydration, props are not\n\t\t// diffed at all (including dangerouslySetInnerHTML)\n\t\tif (flags & MODE_MUTATIVE_HYDRATE) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i].name;\n\t\t\t\tif (!(value in newProps)) {\n\t\t\t\t\tdom.removeAttribute(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newHtml, newValue, newChildren;\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i === 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i === 'value') {\n\t\t\t\tnewValue = value;\n\t\t\t} else if (\n\t\t\t\tvalue != null &&\n\t\t\t\t(isFullRender || typeof value == 'function')\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, null, isSvg);\n\t\t\t}\n\t\t}\n\n\t\tinternal.data = dom;\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tif (isFullRender && newHtml.__html) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\t\t} else if (newChildren != null) {\n\t\t\tmountChildren(\n\t\t\t\tinternal,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tdom,\n\t\t\t\tisNew ? null : dom.firstChild,\n\t\t\t\trefs\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (isFullRender && newValue != null) {\n\t\t\tsetProperty(dom, 'value', newValue, null, 0);\n\t\t}\n\t}\n\n\t// @ts-ignore\n\treturn isNew ? null : dom.nextSibling;\n}\n\n/**\n * Mount all children of an Internal\n * @param {import('../internal').Internal} internal The parent Internal of the given children\n * @param {import('../internal').ComponentChild[]} children\n * @param {import('../internal').PreactElement} parentDom The element into which this subtree is rendered\n * @param {import('../internal').PreactNode} startDom\n */\nexport function mountChildren(internal, children, parentDom, startDom, refs) {\n\tlet internalChildren = (internal._children = []),\n\t\ti,\n\t\tchildVNode,\n\t\tchildInternal,\n\t\tnewDom,\n\t\tmountedNextChild;\n\n\tfor (i = 0; i < children.length; i++) {\n\t\tchildVNode = normalizeToVNode(children[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tinternalChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = createInternal(childVNode, internal);\n\t\tinternalChildren[i] = childInternal;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tmountedNextChild = mount(childInternal, childVNode, parentDom, startDom);\n\n\t\tnewDom = childInternal.data;\n\n\t\tif (childInternal.flags & TYPE_COMPONENT || newDom == startDom) {\n\t\t\t// If the child is a Fragment-like or if it is DOM VNode and its _dom\n\t\t\t// property matches the dom we are diffing (i.e. startDom), just\n\t\t\t// continue with the mountedNextChild\n\t\t\tstartDom = mountedNextChild;\n\t\t} else if (newDom != null) {\n\t\t\t// The DOM the diff should begin with is now startDom (since we inserted\n\t\t\t// newDom before startDom) so ignore mountedNextChild and continue with\n\t\t\t// startDom\n\t\t\tparentDom.insertBefore(newDom, startDom);\n\t\t}\n\n\t\tif (childInternal.ref) {\n\t\t\tif (refs) {\n\t\t\t\trefs.push(childInternal, undefined);\n\t\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\t} else {\n\t\t\t\tapplyRef(\n\t\t\t\t\tchildInternal.ref,\n\t\t\t\t\tchildInternal._component || newDom,\n\t\t\t\t\tchildInternal\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode.\n\tif (\n\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE) &&\n\t\tinternal.flags & TYPE_ELEMENT\n\t) {\n\t\t// TODO: Would it be simpler to just clear the pre-existing DOM in top-level\n\t\t// render if render is called with no oldVNode & existing children & no\n\t\t// replaceNode? Instead of patching the DOM to match the VNode tree? (remove\n\t\t// attributes & unused DOM)\n\t\twhile (startDom) {\n\t\t\ti = startDom;\n\t\t\tstartDom = startDom.nextSibling;\n\t\t\ti.remove();\n\t\t}\n\t}\n\n\treturn startDom;\n}\n\n/**\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @param {import('../internal').PreactNode} startDom the preceding node\n * @returns {import('../internal').PreactNode} the component's children\n */\nfunction mountComponent(internal, startDom) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet type = /** @type {import('../internal').ComponentType} */ (internal.type);\n\tlet newProps = internal.props;\n\n\t// Necessary for createContext api. Setting this property will pass\n\t// the context value as `this.context` just for this component.\n\tlet context = getParentContext(internal);\n\tlet tmp = type.contextType;\n\tlet provider = tmp && context[tmp._id];\n\tlet componentContext = tmp\n\t\t? provider\n\t\t\t? provider.props.value\n\t\t\t: tmp._defaultValue\n\t\t: context;\n\n\tif (provider) provider._subs.add(internal);\n\n\tif (internal.flags & TYPE_CLASS) {\n\t\t// @ts-ignore `type` is a class component constructor\n\t\t// eslint-disable-next-line\n\t\tc = new type(newProps, componentContext);\n\t} else {\n\t\tc = {\n\t\t\tprops: newProps,\n\t\t\tcontext: componentContext,\n\t\t\tforceUpdate: internal.rerender.bind(null, internal)\n\t\t};\n\t}\n\n\tc._internal = internal;\n\tinternal._component = c;\n\tinternal.flags |= DIRTY_BIT;\n\n\tif (!c.state) c.state = {};\n\tif (c._nextState == null) c._nextState = c.state;\n\n\tif (ENABLE_CLASSES) {\n\t\tif (type.getDerivedStateFromProps != null) {\n\t\t\tif (c._nextState == c.state) {\n\t\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t\t}\n\n\t\t\tObject.assign(\n\t\t\t\tc._nextState,\n\t\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t);\n\t\t}\n\n\t\tif (type.getDerivedStateFromProps == null && c.componentWillMount != null) {\n\t\t\tc.componentWillMount();\n\t\t}\n\n\t\tif (c.componentDidMount != null) {\n\t\t\t// If the component was constructed, queue up componentDidMount so the\n\t\t\t// first time this internal commits (regardless of suspense or not) it\n\t\t\t// will be called\n\t\t\tinternal.data._commitCallbacks.push(c.componentDidMount.bind(c));\n\t\t}\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\tc.state = c._nextState;\n\n\tlet renderHook = options._render;\n\tif (renderHook) renderHook(internal);\n\n\tlet counter = 0,\n\t\trenderResult;\n\n\twhile (counter++ < 25) {\n\t\tinternal.flags &= ~DIRTY_BIT;\n\t\tif (renderHook) renderHook(internal);\n\t\tif (ENABLE_CLASSES && internal.flags & TYPE_CLASS) {\n\t\t\trenderResult = c.render(c.props, c.state, c.context);\n\t\t\tfor (let i = 0; i < internal.data._stateCallbacks.length; i++) {\n\t\t\t\tinternal.data._commitCallbacks.push(internal.data._stateCallbacks[i]);\n\t\t\t}\n\t\t\tinternal.data._stateCallbacks = [];\n\t\t\t// note: disable repeat render invocation for class components\n\t\t\tbreak;\n\t\t} else {\n\t\t\trenderResult = type.call(c, c.props, c.context);\n\t\t}\n\n\t\tif (!(internal.flags & DIRTY_BIT)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\tinternal.data._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\tif (renderResult == null) {\n\t\treturn startDom;\n\t}\n\n\tif (typeof renderResult == 'object') {\n\t\t// dissolve unkeyed root fragments:\n\t\tif (renderResult.type === Fragment && renderResult.key == null) {\n\t\t\trenderResult = renderResult.props.children;\n\t\t}\n\t\tif (!isArray(renderResult)) {\n\t\t\trenderResult = [renderResult];\n\t\t}\n\t} else {\n\t\trenderResult = [renderResult];\n\t}\n\n\treturn renderResult;\n}\n","import { enqueueRender } from './component';\nimport { FORCE_UPDATE } from './constants';\n\nlet nextContextId = 0;\n\nconst providers = new Set();\n\n/** @param {import('./internal').Internal} internal */\nexport const unsubscribeFromContext = internal => {\n\t// if this was a context provider, delete() returns true and we exit:\n\tif (providers.delete(internal)) return;\n\t// ... otherwise, unsubscribe from any contexts:\n\tproviders.forEach(p => {\n\t\tp._component._subs.delete(internal);\n\t});\n};\n\nexport const createContext = (defaultValue, contextId) => {\n\tcontextId = '__cC' + nextContextId++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props, ctx) {\n\t\t\t// initial setup:\n\t\t\tif (!this._subs) {\n\t\t\t\tthis._subs = new Set();\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\t\t\t\tthis.getChildContext = () => ctx;\n\t\t\t\tproviders.add(this._internal);\n\t\t\t}\n\t\t\t// re-render subscribers in response to value change\n\t\t\telse if (props.value !== this._prev) {\n\t\t\t\tthis._subs.forEach(internal => {\n\t\t\t\t\tinternal.flags |= FORCE_UPDATE;\n\t\t\t\t\tenqueueRender(internal);\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._prev = props.value;\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n};\n","import { MODE_UNMOUNTING, TYPE_DOM, TYPE_ROOT } from '../constants';\nimport { unsubscribeFromContext } from '../create-context';\nimport options from '../options';\nimport { applyRef } from './refs';\nimport { ENABLE_CLASSES } from '../component';\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').Internal} internal The virtual node to unmount\n * @param {import('../internal').Internal} parentInternal The parent of the VNode that\n * initiated the unmount\n * @param {number} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(internal, parentInternal, skipRemove) {\n\tlet r,\n\t\ti = 0;\n\tif (options.unmount) options.unmount(internal);\n\tinternal.flags |= MODE_UNMOUNTING;\n\n\tif ((r = internal.ref)) {\n\t\tapplyRef(r, null, parentInternal);\n\t}\n\n\tif ((r = internal._component)) {\n\t\tunsubscribeFromContext(internal);\n\n\t\tif (ENABLE_CLASSES && r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentInternal);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((r = internal._children)) {\n\t\tfor (; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentInternal,\n\t\t\t\t\tskipRemove ? ~internal.flags & TYPE_ROOT : internal.flags & TYPE_DOM\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && internal.flags & TYPE_DOM) {\n\t\tinternal.data.remove();\n\t\tinternal.data = null;\n\t}\n}\n","import { applyRef } from './refs';\nimport { normalizeToVNode } from '../create-element';\nimport {\n\tTYPE_COMPONENT,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tEMPTY_ARR,\n\tTYPE_DOM,\n\tUNDEFINED\n} from '../constants';\nimport { mount } from './mount';\nimport { patch } from './patch';\nimport { unmount } from './unmount';\nimport { createInternal, getDomSibling } from '../tree';\nimport { isArray } from '../util';\n\n/**\n * Update an internal with new children.\n * @param {import('../internal').Internal} internal The internal whose children should be patched\n * @param {import('../internal').ComponentChild[]} children The new children, represented as VNodes\n * @param {import('../internal').PreactElement} parentDom The element into which this subtree is rendered\n */\nexport function patchChildren(internal, children, parentDom) {\n\tlet oldChildren =\n\t\t(internal._children && internal._children.slice()) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\tlet remainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\tlet i;\n\n\tlet refs;\n\t/** @type {import('../internal').Internal} */\n\tlet childInternal;\n\n\t/** @type {import('../internal').ComponentChild} */\n\tlet childVNode;\n\n\t/** @type {import('../internal').Internal[]} */\n\tconst newChildren = [];\n\n\tfor (i = 0; i < children.length; i++) {\n\t\tchildVNode = normalizeToVNode(children[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tnewChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet skewedIndex = i + skew;\n\n\t\t/// TODO: Reconsider if we should bring back the \"not moving text nodes\" logic?\n\t\tlet matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\tif (matchingIndex === -1) {\n\t\t\tchildInternal = UNDEFINED;\n\t\t} else {\n\t\t\tchildInternal = oldChildren[matchingIndex];\n\t\t\toldChildren[matchingIndex] = UNDEFINED;\n\t\t\tremainingOldChildren--;\n\t\t}\n\n\t\tlet mountingChild = childInternal == null;\n\n\t\tif (mountingChild) {\n\t\t\tchildInternal = createInternal(childVNode, internal);\n\n\t\t\tif (!refs) refs = [];\n\n\t\t\tif (childVNode.ref) {\n\t\t\t\trefs.push(childInternal, undefined);\n\t\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\t}\n\n\t\t\t// We are mounting a new VNode\n\t\t\tmount(\n\t\t\t\tchildInternal,\n\t\t\t\tchildVNode,\n\t\t\t\tparentDom,\n\t\t\t\tgetDomSibling(internal, skewedIndex),\n\t\t\t\trefs\n\t\t\t);\n\t\t}\n\t\t// If this node suspended during hydration, and no other flags are set:\n\t\t// @TODO: might be better to explicitly check for MODE_ERRORED here.\n\t\telse if (\n\t\t\t(childInternal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t) {\n\t\t\tif (!refs) refs = [];\n\n\t\t\tif (childVNode.ref) {\n\t\t\t\trefs.push(childInternal, undefined);\n\t\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\t}\n\n\t\t\t// We are resuming the hydration of a VNode\n\t\t\tmount(childInternal, childVNode, parentDom, childInternal.data);\n\t\t} else {\n\t\t\tif (childInternal.ref != childVNode.ref) {\n\t\t\t\tif (!refs) refs = [];\n\t\t\t\trefs.push(childInternal, childInternal.ref);\n\t\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\t}\n\n\t\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\t\tpatch(childInternal, childVNode, parentDom);\n\t\t}\n\n\t\tgo: if (mountingChild) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// Perform insert of new dom\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tparentDom.insertBefore(\n\t\t\t\t\tchildInternal.data,\n\t\t\t\t\tgetDomSibling(internal, skewedIndex)\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// Move this DOM into its correct place\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t\tbreak go;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > children.length - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t\tbreak go;\n\t\t\t\t} else {\n\t\t\t\t\t// ### Change from keyed: I think this was missing from the algo...\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\tskewedIndex = i + skew;\n\n\t\t\tif (matchingIndex == i) break go;\n\n\t\t\tlet nextSibling = getDomSibling(internal, skewedIndex + 1);\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tparentDom.insertBefore(childInternal.data, nextSibling);\n\t\t\t} else {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t}\n\t\t}\n\n\t\tnewChildren[i] = childInternal;\n\t}\n\n\tinternal._children = newChildren;\n\n\t// Remove remaining oldChildren if there are any.\n\tif (remainingOldChildren > 0) {\n\t\tfor (i = oldChildrenLength; i--; ) {\n\t\t\tif (oldChildren[i] != null) {\n\t\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i += 2) {\n\t\t\tconst internal = refs[i];\n\t\t\tif (refs[i + 1]) applyRef(refs[i + 1], null, internal);\n\t\t\tif (internal && internal.ref)\n\t\t\t\tapplyRef(internal.ref, internal._component || internal.data, internal);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('../internal').VNode | string} childVNode\n * @param {import('../internal').Internal[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst type = typeof childVNode == 'string' ? null : childVNode.type;\n\tconst key = type !== null ? childVNode.key : UNDEFINED;\n\tlet match = -1;\n\tlet x = skewedIndex - 1; // i - 1;\n\tlet y = skewedIndex + 1; // i + 1;\n\tlet oldChild = oldChildren[skewedIndex]; // i\n\n\tif (\n\t\t// ### Change from keyed: support for matching null placeholders\n\t\toldChild === null ||\n\t\t(oldChild != null && oldChild.type === type && oldChild.key == key)\n\t) {\n\t\tmatch = skewedIndex; // i\n\t}\n\t// If there are any unused children left (ignoring an available in-place child which we just checked)\n\telse if (remainingOldChildren > (oldChild != null ? 1 : 0)) {\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldChild = oldChildren[x];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldChild = oldChildren[y];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t} else if (x < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} nextSibling\n * @param {import('../internal').PreactNode} parentDom\n */\nexport function insertComponentDom(internal, nextSibling, parentDom) {\n\tif (internal._children == null) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < internal._children.length; i++) {\n\t\tlet childInternal = internal._children[i];\n\t\tif (childInternal) {\n\t\t\tchildInternal._parent = internal;\n\n\t\t\tif (childInternal.flags & TYPE_COMPONENT) {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t} else if (childInternal.data != nextSibling) {\n\t\t\t\tparentDom.insertBefore(childInternal.data, nextSibling);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tfor (children of children) {\n\t\t\ttoChildArray(children, out);\n\t\t}\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n","import { patchChildren, insertComponentDom } from './children';\nimport { setProperty } from './props';\nimport options from '../options';\nimport {\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_ELEMENT,\n\tMODE_SUSPENDED,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tTYPE_CLASS,\n\tMODE_SVG,\n\tUNDEFINED,\n\tMODE_HYDRATE,\n\tMODE_PENDING_ERROR,\n\tMODE_RERENDERING_ERROR,\n\tSKIP_CHILDREN,\n\tDIRTY_BIT,\n\tFORCE_UPDATE\n} from '../constants';\nimport { getDomSibling, getParentContext } from '../tree';\nimport { mountChildren } from './mount';\nimport { Fragment } from '../create-element';\nimport { ENABLE_CLASSES } from '../component';\nimport { commitQueue } from './commit';\nimport { isArray } from '../util';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').VNode | string} vnode The new virtual node\n * @param {import('../internal').PreactElement} parentDom The element into which this subtree is rendered\n */\nexport function patch(internal, vnode, parentDom) {\n\tlet flags = internal.flags;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (vnode !== internal.props) {\n\t\t\t// @ts-ignore We know that newVNode is string/number/bigint, and internal.data is Text\n\t\t\tinternal.data.data = vnode;\n\t\t\tinternal.props = vnode;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (vnode.constructor !== UNDEFINED) return;\n\n\tif (options._diff) options._diff(internal, vnode);\n\n\t// Root nodes render their children into a specific parent DOM element.\n\t// They can occur anywhere in the tree, can be nested, and currently allow reparenting during patches.\n\t// @TODO: Decide if we actually want to support silent reparenting during patch - is it worth the bytes?\n\tlet prevParentDom = parentDom;\n\tif (flags & TYPE_ROOT) {\n\t\tparentDom = vnode.props._parentDom;\n\n\t\tif (internal.props._parentDom !== vnode.props._parentDom) {\n\t\t\tlet nextSibling =\n\t\t\t\tparentDom == prevParentDom ? getDomSibling(internal) : null;\n\t\t\tinsertComponentDom(internal, nextSibling, parentDom);\n\t\t}\n\t}\n\n\tif (flags & TYPE_ELEMENT) {\n\t\tif (vnode._vnodeId !== internal._vnodeId) {\n\t\t\t// @ts-ignore dom is a PreactElement here\n\t\t\tpatchElement(internal, vnode);\n\t\t\tinternal.props = vnode.props;\n\t\t}\n\t} else {\n\t\tif (flags & MODE_PENDING_ERROR) {\n\t\t\t// Toggle the MODE_PENDING_ERROR and MODE_RERENDERING_ERROR flags. In\n\t\t\t// actuality, this should turn off the MODE_PENDING_ERROR flag and turn on\n\t\t\t// the MODE_RERENDERING_ERROR flag.\n\t\t\tinternal.flags ^= MODE_PENDING_ERROR | MODE_RERENDERING_ERROR;\n\t\t}\n\n\t\ttry {\n\t\t\tlet renderResult;\n\t\t\tif (internal._vnodeId === vnode._vnodeId) {\n\t\t\t\tinternal.flags |= SKIP_CHILDREN;\n\t\t\t} else {\n\t\t\t\trenderResult = patchComponent(internal, vnode);\n\t\t\t}\n\n\t\t\tif (internal.flags & SKIP_CHILDREN) {\n\t\t\t\tinternal._component.props = internal.props = vnode.props;\n\t\t\t\tif (vnode._vnodeId !== internal._vnodeId) {\n\t\t\t\t\tinternal.flags &= ~DIRTY_BIT;\n\t\t\t\t}\n\t\t\t} else if (internal._children == null) {\n\t\t\t\tlet siblingDom =\n\t\t\t\t\t(internal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t\t\t\t\t? internal.data\n\t\t\t\t\t\t: internal.flags & MODE_HYDRATE\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: getDomSibling(internal);\n\n\t\t\t\tmountChildren(internal, renderResult, parentDom, siblingDom);\n\t\t\t} else {\n\t\t\t\tpatchChildren(internal, renderResult, parentDom);\n\t\t\t}\n\n\t\t\t// TODO: for some reason lazy-hydration stops working as .data is assigned a DOM-node\n\t\t\t// for Preact.lazy\n\t\t\tif (\n\t\t\t\tinternal.data._commitCallbacks &&\n\t\t\t\tinternal.data._commitCallbacks.length\n\t\t\t) {\n\t\t\t\tcommitQueue.push(internal);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// @TODO: assign a new VNode ID here? Or NaN?\n\t\t\t// newVNode._vnodeId = 0;\n\t\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t}\n\n\tif (options.diffed) options.diffed(internal);\n\n\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\tinternal.flags &= RESET_MODE;\n\n\t// Once we have successfully rendered the new VNode, copy it's ID over\n\tinternal._vnodeId = vnode._vnodeId;\n}\n\n/**\n * Update an internal and its associated DOM element based on a new VNode\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').VNode} vnode A VNode with props to compare and apply\n */\nfunction patchElement(internal, vnode) {\n\tlet dom = /** @type {import('../internal').PreactElement} */ (internal.data),\n\t\toldProps = internal.props,\n\t\tnewProps = vnode.props,\n\t\tisSvg = internal.flags & MODE_SVG,\n\t\ti,\n\t\tvalue,\n\t\ttmp,\n\t\tnewHtml,\n\t\toldHtml,\n\t\tnewChildren;\n\n\tfor (i in oldProps) {\n\t\tvalue = oldProps[i];\n\t\tif (i === 'children') {\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\toldHtml = value;\n\t\t} else if (!(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tvalue = newProps[i];\n\t\tif (i === 'children') {\n\t\t\tnewChildren = value;\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\tnewHtml = value;\n\t\t} else if (\n\t\t\tvalue !== (tmp = oldProps[i]) ||\n\t\t\t((i === 'checked' || i === 'value') && value != null && value !== dom[i])\n\t\t) {\n\t\t\tsetProperty(dom, i, value, tmp, isSvg);\n\t\t}\n\t}\n\n\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\tif (newHtml) {\n\t\tvalue = newHtml.__html;\n\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\tif (!oldHtml || (value !== oldHtml.__html && value !== dom.innerHTML)) {\n\t\t\tdom.innerHTML = value;\n\t\t}\n\t\tinternal._children = null;\n\t} else {\n\t\tif (oldHtml) dom.innerHTML = '';\n\t\tpatchChildren(\n\t\t\tinternal,\n\t\t\tnewChildren && isArray(newChildren) ? newChildren : [newChildren],\n\t\t\tdom\n\t\t);\n\t}\n}\n\n/**\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @returns {import('../internal').ComponentChildren} the component's children\n */\nfunction patchComponent(internal, newVNode) {\n\tlet type = /** @type {import('../internal').ComponentType} */ (internal.type);\n\tlet snapshot,\n\t\tc = internal._component,\n\t\tnewProps = newVNode.props;\n\n\t// Necessary for createContext api. Setting this property will pass\n\t// the context value as `this.context` just for this component.\n\tlet context = getParentContext(internal);\n\tlet tmp = newVNode.type.contextType;\n\tlet provider = tmp && context[tmp._id];\n\tlet componentContext = tmp\n\t\t? provider\n\t\t\t? provider.props.value\n\t\t\t: tmp._defaultValue\n\t\t: context;\n\n\tif (c._nextState == null) {\n\t\tc._nextState = c.state;\n\t}\n\n\tlet oldProps = c.props;\n\tlet oldState = c.state;\n\n\tif (ENABLE_CLASSES) {\n\t\tif (type.getDerivedStateFromProps != null) {\n\t\t\tif (c._nextState == c.state) {\n\t\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t\t}\n\n\t\t\tObject.assign(\n\t\t\t\tc._nextState,\n\t\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\ttype.getDerivedStateFromProps == null &&\n\t\t\tnewProps !== oldProps &&\n\t\t\tc.componentWillReceiveProps != null\n\t\t) {\n\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t}\n\t}\n\n\tif (\n\t\t!(internal.flags & FORCE_UPDATE) &&\n\t\tc.shouldComponentUpdate != null &&\n\t\tc.shouldComponentUpdate(newProps, c._nextState, componentContext) === false\n\t) {\n\t\tc.props = newProps;\n\t\tc.state = c._nextState;\n\t\tinternal.flags |= SKIP_CHILDREN;\n\t\tfor (let i = 0; i < internal.data._stateCallbacks.length; i++) {\n\t\t\tinternal.data._commitCallbacks.push(internal.data._stateCallbacks[i]);\n\t\t}\n\t\tinternal.data._stateCallbacks = [];\n\t\treturn;\n\t}\n\n\tif (ENABLE_CLASSES && c.componentWillUpdate != null) {\n\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\tc.state = c._nextState;\n\n\tlet renderHook = options._render;\n\tif (renderHook) renderHook(internal);\n\n\tlet counter = 0,\n\t\trenderResult;\n\twhile (counter++ < 25) {\n\t\tinternal.flags &= ~DIRTY_BIT;\n\t\tif (renderHook) renderHook(internal);\n\t\tif (ENABLE_CLASSES && internal.flags & TYPE_CLASS) {\n\t\t\trenderResult = c.render(c.props, c.state, c.context);\n\t\t\tfor (let i = 0; i < internal.data._stateCallbacks.length; i++) {\n\t\t\t\tinternal.data._commitCallbacks.push(internal.data._stateCallbacks[i]);\n\t\t\t}\n\t\t\tinternal.data._stateCallbacks = [];\n\t\t\t// note: disable repeat render invocation for class components\n\t\t\tbreak;\n\t\t} else {\n\t\t\trenderResult = type.call(c, c.props, c.context);\n\t\t}\n\t\tif (!(internal.flags & DIRTY_BIT)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\tinternal.data._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\tif (ENABLE_CLASSES) {\n\t\tif (c.getSnapshotBeforeUpdate != null) {\n\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t}\n\n\t\t// Only schedule componentDidUpdate if the component successfully rendered\n\t\tif (c.componentDidUpdate != null) {\n\t\t\tinternal.data._commitCallbacks.push(() => {\n\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t});\n\t\t}\n\t}\n\n\tif (renderResult == null) {\n\t\trenderResult = [];\n\t} else if (typeof renderResult == 'object') {\n\t\tif (renderResult.type === Fragment && renderResult.key == null) {\n\t\t\trenderResult = renderResult.props.children;\n\t\t}\n\t\tif (!isArray(renderResult)) {\n\t\t\trenderResult = [renderResult];\n\t\t}\n\t} else {\n\t\trenderResult = [renderResult];\n\t}\n\n\treturn renderResult;\n}\n","import { commitRoot } from './diff/commit';\nimport options from './options';\nimport { createElement, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentDom } from './tree';\n\nexport let ENABLE_CLASSES = false;\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tENABLE_CLASSES = true;\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tconst internal = this._internal;\n\tif (update != null && internal) {\n\t\tif (callback) internal.data._stateCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function (callback) {\n\tconst internal = this._internal;\n\tif (internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tinternal.flags |= FORCE_UPDATE;\n\t\tif (callback) internal.data._commitCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction renderQueuedInternal(internal) {\n\t// Don't render unmounting/unmounted trees:\n\tif (internal.flags & MODE_UNMOUNTING) return;\n\n\t// Don't render trees already rendered in this pass:\n\tif (!(internal.flags & DIRTY_BIT)) return;\n\n\tconst vnode = createElement(internal.type, internal.props);\n\tvnode.props = internal.props;\n\n\tpatch(internal, vnode, getParentDom(internal));\n\tcommitRoot(internal);\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet renderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trenderQueue.push(internal) &&\n\t\t\t!processRenderQueue._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(processRenderQueue);\n\t}\n}\n\n/**\n * @param {import('./internal').Internal} a\n * @param {import('./internal').Internal} b\n */\nconst depthSort = (a, b) => a._depth - b._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction processRenderQueue() {\n\tlet c;\n\trenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = renderQueue.shift())) {\n\t\tif (c.flags & DIRTY_BIT) {\n\t\t\tlet renderQueueLength = renderQueue.length;\n\t\t\trenderQueuedInternal(c);\n\t\t\tif (renderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocessRenderQueue._rerenderCount = 0;\n}\nprocessRenderQueue._rerenderCount = 0;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import {\n\tDIRTY_BIT,\n\tMODE_RERENDERING_ERROR,\n\tMODE_PENDING_ERROR,\n\tTYPE_COMPONENT\n} from '../constants';\nimport { ENABLE_CLASSES } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').Internal} internal The Internal node that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, internal) {\n\twhile ((internal = internal._parent)) {\n\t\tif (\n\t\t\tinternal.flags & TYPE_COMPONENT &&\n\t\t\t~internal.flags & MODE_RERENDERING_ERROR\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (ENABLE_CLASSES) {\n\t\t\t\t\tif (internal.type.getDerivedStateFromError) {\n\t\t\t\t\t\tinternal._component.setState(\n\t\t\t\t\t\t\tinternal.type.getDerivedStateFromError(error)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (internal._component.componentDidCatch) {\n\t\t\t\t\t\tinternal._component.componentDidCatch(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// NOTE: We're checking that any component in the stack got marked as dirty, even if it did so prior to this loop,\n\t\t\t\t// which is technically incorrect. However, there is no way for a component to mark itself as dirty during rendering.\n\t\t\t\t// The only way for a component to falsely intercept error bubbling would be to manually sets its internal dirty flag.\n\t\t\t\tif (internal.flags & DIRTY_BIT) {\n\t\t\t\t\tinternal.flags |= MODE_PENDING_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import options from '../options';\n\n/**\n * A list of components with effects that need to be run at the end of the current render pass.\n * @type {import('../internal').CommitQueue}\n */\nexport let commitQueue = [];\n\n/**\n * @param {import('../internal').Internal} rootInternal\n */\nexport function commitRoot(rootInternal) {\n\tlet currentQueue = commitQueue;\n\tcommitQueue = [];\n\n\tif (options._commit) options._commit(rootInternal, currentQueue);\n\n\tcurrentQueue.some(internal => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the root variable here so the type changes\n\t\t\tcurrentQueue = internal.data._commitCallbacks.length;\n\t\t\t// @ts-ignore See above ts-ignore comment\n\t\t\twhile (currentQueue--) {\n\t\t\t\tinternal.data._commitCallbacks.shift()();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\n\n/**\n *\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * @returns {import('./internal').Root}\n */\nexport function createRoot(parentDom) {\n\tlet rootInternal,\n\t\tfirstChild,\n\t\tflags = 0;\n\n\tfunction render(vnode) {\n\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\t\tfirstChild = /** @type {import('./internal').PreactElement} */ (\n\t\t\tparentDom.firstChild\n\t\t);\n\n\t\tif (rootInternal) {\n\t\t\tpatch(rootInternal, vnode, parentDom);\n\t\t} else {\n\t\t\trootInternal = createInternal(vnode);\n\n\t\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\t\tparentDom._children = rootInternal;\n\n\t\t\t// Calling createRoot().render() on an Element with existing children triggers mutative hydrate mode:\n\t\t\tif (firstChild) {\n\t\t\t\tflags = flags || MODE_MUTATIVE_HYDRATE;\n\t\t\t}\n\t\t\t// If the parent of this tree is within an inline SVG, the tree should start off in SVG mode:\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\tflags |= MODE_SVG;\n\t\t\t}\n\t\t\trootInternal.flags |= flags;\n\n\t\t\trootInternal.data._context = {};\n\n\t\t\tmount(rootInternal, vnode, parentDom, firstChild);\n\t\t}\n\n\t\t// Flush all queued effects\n\t\tcommitRoot(rootInternal);\n\t}\n\n\treturn {\n\t\thydrate(vnode) {\n\t\t\tflags |= MODE_HYDRATE;\n\t\t\trender(vnode);\n\t\t},\n\t\trender\n\t};\n}\n","import { createRoot } from './create-root';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.render(vnode);\n\tparentDom._root = root;\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.hydrate(vnode);\n\tparentDom._root = root;\n}\n","import { EMPTY_ARR } from './constants';\nimport { createElement } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tif (arguments.length > 3) {\n\t\tchildren = EMPTY_ARR.slice.call(arguments, 2);\n\t}\n\n\tconst clonedProps = Object.assign(\n\t\t{ key: vnode.key, ref: vnode.ref },\n\t\tvnode.props,\n\t\tprops\n\t);\n\n\treturn createElement(vnode.type, clonedProps, children);\n}\n","import { createElement } from './create-element';\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\treturn props.children;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\t// Note: We can't use Fragment here because a component that returned a Portal\n\t// (e.g. `const App = () => createPortal(...)`) wouldn't work. Our diff\n\t// collapses Fragments without keys that are returned directly from components\n\t// into just an array and sets that as the children array of the component.\n\t//\n\t// We also can't use keyed Fragments here cuz it might lead to weird edge\n\t// cases when toggling between two sibling portals if we use a shared keyed or\n\t// lead to unnecessary re-mounts if trying to generate a new key on each call.\n\t//\n\t// So the simplest solution seems to be just to use an unique type for Portal\n\t// to skip the Fragment collapsing logic when diffing components\n\tconst el = createElement(Portal, { _parentDom: container }, vnode);\n\tel.containerInfo = container;\n\treturn el;\n}\n"],"names":["EMPTY_ARR","isArray","Array","vnodeId","createElement","type","props","children","key","ref","i","normalizedProps","arguments","length","push","undefined","vnode","constructor","__v","options","normalizeToVNode","childVNode","Fragment","String","createRef","current","isValidElement","applyRef","value","internal","e","setStyle","dom","style","setProperty","name","oldValue","isSvg","useCapture","o","replace","toLowerCase","slice","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","removeAttribute","setAttribute","event","createInternal","parentInternal","flags","MODE_HYDRATE","prototype","render","data","TYPE_CLASS","__h","c","_sb","rerender","enqueueRender","__k","__","__c","__b","shouldSearchComponent","getParentDom","getDomSibling","childIndex","indexOf","getChildDom","offset","child","TYPE_TEXT","childDom","getParentContext","parent","mount","newVNode","parentDom","startDom","refs","nextDomSibling","prevStartDom","renderResult","mountComponent","mountChildren","commitQueue","mountElement","diffed","then","nextSibling","newProps","nodeType","isFullRender","localName","isNew","document","createTextNode","createElementNS","is","attributes","newHtml","newValue","newChildren","innerHTML","firstChild","childInternal","newDom","mountedNextChild","internalChildren","insertBefore","remove","context","tmp","contextType","provider","componentContext","add","forceUpdate","bind","state","ENABLE_CLASSES","getDerivedStateFromProps","Object","assign","componentWillMount","componentDidMount","renderHook","counter","call","getChildContext","nextContextId","providers","Set","unsubscribeFromContext","delete","forEach","p","createContext","defaultValue","contextId","Consumer","contextValue","Provider","ctx","this","unmount","skipRemove","r","componentWillUnmount","patchChildren","oldChildren","oldChildrenLength","remainingOldChildren","skew","skewedIndex","matchingIndex","findMatchingIndex","mountingChild","patch","go","insertComponentDom","match","x","y","oldChild","toChildArray","out","prevParentDom","patchElement","MODE_PENDING_ERROR","patchComponent","oldHtml","oldProps","snapshot","oldState","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","getSnapshotBeforeUpdate","componentDidUpdate","Component","renderQueuedInternal","commitRoot","setState","update","callback","s","prevDebounce","renderQueue","defer","Promise","resolve","processRenderQueue","debounceRendering","depthSort","a","b","sort","shift","renderQueueLength","[object Object]","error","getDerivedStateFromError","componentDidCatch","rootInternal","currentQueue","some","createRoot","__P","ownerSVGElement","hydrate","root","cloneElement","clonedProps","Portal","createPortal","container","el","containerInfo"],"mappings":"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"}